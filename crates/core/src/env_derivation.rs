//! Environment derivations for sys.lua
//!
//! Environment derivations transform `EnvDecl` entries into derivations that output
//! shell script fragments. These fragments are aggregated into profile scripts.
//!
//! # Model
//!
//! Each `env {}` call creates a derivation that outputs shell fragments for each
//! supported shell (bash, zsh, fish, powershell). These are stored at:
//!
//! ```text
//! store/obj/env-<name>-<hash>/
//!   bash.sh
//!   zsh.zsh
//!   fish.fish
//!   sh.sh
//! ```
//!
//! # Aggregation
//!
//! The profile scripts are generated by concatenating all env derivation outputs
//! in deterministic order at:
//!
//! ```text
//! ~/.local/share/syslua/
//!   env.sh      # Bash/Zsh/Sh
//!   env.zsh     # Zsh-specific
//!   env.fish    # Fish
//!   env.ps1     # PowerShell
//! ```

use crate::Result;
use crate::derivation::{Derivation, DerivationSpec, InputValue, System};
use crate::store::{Store, sha256_string};
use std::collections::BTreeMap;
use std::fs;
use std::path::{Path, PathBuf};
use sys_lua::{EnvDecl, EnvMergeStrategy};
use sys_platform::Shell;
use tracing::{debug, info};

/// Build an environment derivation from an EnvDecl.
///
/// Creates a derivation that outputs shell script fragments for each supported shell.
pub fn build_env_derivation(decl: &EnvDecl, store: &Store) -> Result<Derivation> {
    // Build inputs for the derivation
    let mut inputs = BTreeMap::new();
    inputs.insert("type".to_string(), InputValue::String("env".to_string()));
    inputs.insert("name".to_string(), InputValue::String(decl.name.clone()));

    // Serialize values as inputs
    let values: Vec<InputValue> = decl
        .values
        .iter()
        .map(|v| {
            let mut table = BTreeMap::new();
            table.insert("value".to_string(), InputValue::String(v.value.clone()));
            table.insert(
                "strategy".to_string(),
                InputValue::String(strategy_to_string(&v.strategy)),
            );
            InputValue::Table(table)
        })
        .collect();
    inputs.insert("values".to_string(), InputValue::Array(values));

    // Compute build hash from the inputs
    let build_hash = sha256_string(&serde_json::to_string(&inputs).unwrap_or_default());

    // Create derivation spec
    let spec = DerivationSpec {
        name: format!("env-{}", decl.name),
        version: None,
        inputs,
        build_hash,
        outputs: vec!["out".to_string()],
        system: System::current(),
    };

    let drv = Derivation::new(spec);

    // Realize the derivation
    let output_path = realize_env_derivation(store, &drv, decl)?;

    // Create a derivation with the output path set
    let mut realized_drv = drv;
    realized_drv
        .output_paths
        .insert("out".to_string(), output_path);
    realized_drv.realized = true;

    info!(
        "Built env derivation: {} -> {}",
        decl.name,
        realized_drv.short_hash()
    );

    Ok(realized_drv)
}

/// Realize an environment derivation.
///
/// Creates shell script fragments in the store.
fn realize_env_derivation(store: &Store, drv: &Derivation, decl: &EnvDecl) -> Result<PathBuf> {
    // Check if already realized via cache
    if let Some(output_hash) = store.lookup_cache(&drv.hash) {
        let path = store.object_path(drv.name(), drv.version(), &output_hash);
        if path.exists() {
            debug!("Env derivation {} already realized", drv.short_hash());
            return Ok(path);
        }
    }

    // Create temporary build output
    let temp_dir = tempfile::tempdir()?;

    // Generate shell fragments for each supported shell
    let shells = [
        (Shell::Bash, "bash.sh"),
        (Shell::Zsh, "zsh.zsh"),
        (Shell::Fish, "fish.fish"),
        (Shell::Sh, "sh.sh"),
    ];

    for (shell, filename) in &shells {
        let content = generate_env_fragment(decl, shell);
        let path = temp_dir.path().join(filename);
        fs::write(&path, content)?;
    }

    // Finalize to store
    let output_path = store.finalize_output(drv, temp_dir.path())?;

    // Save derivation spec
    store.save_derivation(drv)?;

    Ok(output_path)
}

/// Generate a shell fragment for a single environment variable declaration.
fn generate_env_fragment(decl: &EnvDecl, shell: &Shell) -> String {
    let mut lines = Vec::new();

    // Add comment
    lines.push(shell.comment(&format!("Environment: {}", decl.name)));

    for value in &decl.values {
        let line = match value.strategy {
            EnvMergeStrategy::Replace => shell.export_var(&decl.name, &value.value),
            EnvMergeStrategy::Prepend => shell.prepend_path(&decl.name, &value.value),
            EnvMergeStrategy::Append => shell.append_path(&decl.name, &value.value),
        };
        lines.push(line);
    }

    lines.push(String::new()); // Trailing newline
    lines.join("\n")
}

/// Convert merge strategy to string for serialization.
fn strategy_to_string(strategy: &EnvMergeStrategy) -> String {
    match strategy {
        EnvMergeStrategy::Replace => "replace",
        EnvMergeStrategy::Prepend => "prepend",
        EnvMergeStrategy::Append => "append",
    }
    .to_string()
}

/// Process all environment declarations and build derivations.
pub fn process_env_declarations(envs: &[EnvDecl], store: &Store) -> Result<Vec<Derivation>> {
    let mut results = Vec::new();

    for decl in envs {
        let drv = build_env_derivation(decl, store)?;
        results.push(drv);
    }

    Ok(results)
}

/// Generate aggregated profile scripts from env derivations.
///
/// Concatenates all env derivation outputs into profile scripts.
pub fn generate_profile_scripts(env_derivations: &[Derivation], profile_dir: &Path) -> Result<()> {
    // Ensure profile directory exists
    fs::create_dir_all(profile_dir)?;

    // Generate for each shell separately
    let shell_configs = [
        (Shell::Bash, "env.sh", "bash.sh"),
        (Shell::Zsh, "env.zsh", "zsh.zsh"),
        (Shell::Fish, "env.fish", "fish.fish"),
    ];

    for (shell, output_name, fragment_name) in &shell_configs {
        let mut content = Vec::new();

        // Add header
        content.push(shell.header().to_string());
        content.push(shell.comment("Generated by sys.lua - DO NOT EDIT"));
        content.push(shell.comment(&format!(
            "Generated at: {}",
            chrono::Local::now().format("%Y-%m-%d %H:%M:%S")
        )));
        content.push(String::new());

        // Sort derivations for deterministic output
        let mut sorted_drvs: Vec<_> = env_derivations.iter().collect();
        sorted_drvs.sort_by(|a, b| a.name().cmp(b.name()));

        // Concatenate fragments
        for drv in sorted_drvs {
            if let Some(out_path) = drv.out() {
                let fragment_path = out_path.join(fragment_name);
                if fragment_path.exists() {
                    let fragment = fs::read_to_string(&fragment_path)?;
                    content.push(fragment);
                }
            }
        }

        // Write output file
        let path = profile_dir.join(output_name);
        fs::write(&path, content.join("\n"))?;
        debug!("Wrote profile script: {}", path.display());
    }

    info!("Generated profile scripts in {}", profile_dir.display());

    Ok(())
}

/// Get the source command for a profile script.
pub fn profile_source_command(shell: &Shell, profile_dir: &Path) -> String {
    let extension = match shell {
        Shell::Fish => "fish",
        Shell::PowerShell => "ps1",
        Shell::Zsh => "zsh",
        _ => "sh",
    };

    let script_path = profile_dir.join(format!("env.{}", extension));
    let path_str = script_path.display();

    match shell {
        Shell::Fish => format!("source \"{}\"", path_str),
        Shell::PowerShell => format!(". \"{}\"", path_str),
        _ => format!("source \"{}\"", path_str),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sys_lua::EnvValue;
    use tempfile::TempDir;

    fn setup_store() -> (Store, TempDir) {
        let temp = TempDir::new().unwrap();
        let store = Store::new(temp.path().join("store"));
        store.init().unwrap();
        (store, temp)
    }

    #[test]
    fn test_build_env_derivation_simple() {
        let (store, _temp) = setup_store();

        let decl = EnvDecl::new("EDITOR", "nvim");
        let drv = build_env_derivation(&decl, &store).unwrap();

        assert!(drv.realized);
        assert!(drv.out().is_some());

        // Check output files exist
        let out_path = drv.out().unwrap();
        assert!(out_path.join("bash.sh").exists());
        assert!(out_path.join("fish.fish").exists());
        assert!(out_path.join("zsh.zsh").exists());
    }

    #[test]
    fn test_build_env_derivation_path_prepend() {
        let (store, _temp) = setup_store();

        let decl = EnvDecl::path_prepend("PATH", vec!["/usr/local/bin".to_string()]);
        let drv = build_env_derivation(&decl, &store).unwrap();

        // Verify bash fragment
        let bash_content = fs::read_to_string(drv.out().unwrap().join("bash.sh")).unwrap();
        assert!(bash_content.contains("PATH"));
        assert!(bash_content.contains("/usr/local/bin"));
        assert!(bash_content.contains("$PATH"));
    }

    #[test]
    fn test_build_env_derivation_append() {
        let (store, _temp) = setup_store();

        let decl = EnvDecl {
            name: "MANPATH".to_string(),
            values: vec![EnvValue::append("/usr/share/man".to_string())],
        };

        let drv = build_env_derivation(&decl, &store).unwrap();

        let bash_content = fs::read_to_string(drv.out().unwrap().join("bash.sh")).unwrap();
        assert!(bash_content.contains("MANPATH"));
        assert!(bash_content.contains("/usr/share/man"));
    }

    #[test]
    fn test_env_derivation_caching() {
        let (store, _temp) = setup_store();

        let decl = EnvDecl::new("EDITOR", "vim");

        let drv1 = build_env_derivation(&decl, &store).unwrap();
        let drv2 = build_env_derivation(&decl, &store).unwrap();

        // Same derivation hash and output
        assert_eq!(drv1.hash, drv2.hash);
        assert_eq!(drv1.out(), drv2.out());
    }

    #[test]
    fn test_generate_profile_scripts() {
        let (store, temp) = setup_store();
        let profile_dir = temp.path().join("profile");

        // Build some env derivations
        let envs = vec![
            EnvDecl::new("EDITOR", "nvim"),
            EnvDecl::new("PAGER", "less"),
            EnvDecl::path_prepend("PATH", vec!["/opt/bin".to_string()]),
        ];

        let drvs = process_env_declarations(&envs, &store).unwrap();

        // Generate profile scripts
        generate_profile_scripts(&drvs, &profile_dir).unwrap();

        // Verify output files
        assert!(profile_dir.join("env.sh").exists());
        assert!(profile_dir.join("env.fish").exists());
        assert!(profile_dir.join("env.zsh").exists());

        // Verify content
        let bash_content = fs::read_to_string(profile_dir.join("env.sh")).unwrap();
        assert!(bash_content.contains("EDITOR"));
        assert!(bash_content.contains("PAGER"));
        assert!(bash_content.contains("PATH"));
        assert!(bash_content.contains("Generated by sys.lua"));
    }

    #[test]
    fn test_generate_env_fragment() {
        let decl = EnvDecl::new("EDITOR", "nvim");

        let bash_fragment = generate_env_fragment(&decl, &Shell::Bash);
        assert!(bash_fragment.contains("export EDITOR=\"nvim\""));

        let fish_fragment = generate_env_fragment(&decl, &Shell::Fish);
        assert!(fish_fragment.contains("set -gx EDITOR \"nvim\""));
    }

    #[test]
    fn test_profile_source_command() {
        let profile_dir = Path::new("/home/user/.local/share/syslua");

        let bash_cmd = profile_source_command(&Shell::Bash, profile_dir);
        assert!(bash_cmd.contains("source"));
        assert!(bash_cmd.contains("env.sh"));

        let fish_cmd = profile_source_command(&Shell::Fish, profile_dir);
        assert!(fish_cmd.contains("source"));
        assert!(fish_cmd.contains("env.fish"));
    }

    #[test]
    fn test_process_env_declarations() {
        let (store, _temp) = setup_store();

        let envs = vec![
            EnvDecl::new("VAR1", "value1"),
            EnvDecl::new("VAR2", "value2"),
        ];

        let drvs = process_env_declarations(&envs, &store).unwrap();

        assert_eq!(drvs.len(), 2);
        assert!(drvs.iter().all(|d| d.realized));
    }

    #[test]
    fn test_multiple_values() {
        let (store, _temp) = setup_store();

        let decl = EnvDecl {
            name: "PATH".to_string(),
            values: vec![
                EnvValue::prepend("/first".to_string()),
                EnvValue::prepend("/second".to_string()),
            ],
        };

        let drv = build_env_derivation(&decl, &store).unwrap();

        let bash_content = fs::read_to_string(drv.out().unwrap().join("bash.sh")).unwrap();
        assert!(bash_content.contains("/first"));
        assert!(bash_content.contains("/second"));
    }
}
