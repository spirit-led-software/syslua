local prio = require('syslua.priority')

---@class syslua.modules.env
local M = {}

---@class EnvOptions
---@field PATH? string | priority.PriorityValue<string> | priority.Mergeable<string>
---@field vars? table<string, string | priority.PriorityValue<string>>

-- Platform-specific path separators
local PATH_SEP = sys.os == 'windows' and ';' or ':'

-- Default PATH values
local DEFAULT_PATH = sys.os == 'windows' and 'C:\\Windows\\System32;C:\\Windows;C:\\Windows\\System32\\Wbem'
  or '/usr/local/bin:/usr/bin:/bin'

local default_opts = {
  PATH = prio.mergeable({
    separator = PATH_SEP,
    default = DEFAULT_PATH,
  }),
  vars = {},
}

---@type EnvOptions
M.opts = default_opts

-- ============================================================================
-- Helper Functions
-- ============================================================================

--- Get the user's home directory
---@return string
local function get_home()
  -- Use placeholder that resolves at execution time
  return sys.getenv('HOME')
end

--- Escape a string for POSIX shell (bash/zsh)
---@param str string
---@return string
local function escape_posix(str)
  -- Escape single quotes by ending quote, adding escaped quote, starting quote
  return "'" .. str:gsub("'", "'\\''") .. "'"
end

--- Escape a string for fish shell
---@param str string
---@return string
local function escape_fish(str)
  -- Fish uses single quotes with \' for escape
  return "'" .. str:gsub("'", "\\'") .. "'"
end

--- Escape a string for PowerShell
---@param str string
---@return string
local function escape_powershell(str)
  -- PowerShell uses single quotes, double them to escape
  return "'" .. str:gsub("'", "''") .. "'"
end

--- Get shell config file paths based on privilege level
---@return table<string, string>
local function get_shell_configs()
  local home = get_home()

  if sys.is_elevated then
    -- Global config paths
    local bash_global = sys.os == 'darwin' and '/etc/profile' or '/etc/profile.d/syslua-env.sh'
    return {
      zsh = '/etc/zshenv',
      bash = bash_global,
      fish = '/etc/fish/conf.d/syslua-env.fish',
      powershell = 'C:\\Program Files\\PowerShell\\7\\profile.ps1',
    }
  else
    -- User config paths
    return {
      zsh = home .. '/.zshenv',
      bash = home .. '/.bashrc',
      fish = home .. '/.config/fish/config.fish',
      powershell = home .. '/Documents/PowerShell/profile.ps1',
    }
  end
end

--- Convert merged opts to a serializable config
---@param opts EnvOptions
---@return table
local function serialize_env_config(opts)
  local config = {
    PATH = nil,
    vars = {},
  }

  -- Handle PATH
  if opts.PATH then
    if type(opts.PATH) == 'string' then
      config.PATH = opts.PATH
    elseif prio.is_mergeable(opts.PATH) then
      -- Mergeable will be resolved at access time
      config.PATH = nil -- Will be computed during build
    elseif prio.is_priority(opts.PATH) then
      config.PATH = prio.unwrap(opts.PATH)
    end
  end

  -- Handle vars
  if opts.vars then
    for k, v in pairs(opts.vars) do
      if prio.is_priority(v) then
        config.vars[k] = prio.unwrap(v)
      else
        config.vars[k] = v
      end
    end
  end

  return config
end

--- Generate bash/zsh env file content
---@param path_value string|nil
---@param vars table<string, string>
---@return string
local function generate_posix_env(path_value, vars)
  local lines = {
    '# Generated by syslua - DO NOT EDIT',
    '# This file sets environment variables managed by syslua',
    '',
  }

  if path_value then
    table.insert(lines, 'export PATH=' .. escape_posix(path_value))
  end

  for name, value in pairs(vars) do
    table.insert(lines, 'export ' .. name .. '=' .. escape_posix(value))
  end

  table.insert(lines, '')
  return table.concat(lines, '\n')
end

--- Generate fish env file content
---@param path_value string|nil
---@param vars table<string, string>
---@return string
local function generate_fish_env(path_value, vars)
  local lines = {
    '# Generated by syslua - DO NOT EDIT',
    '# This file sets environment variables managed by syslua',
    '',
  }

  if path_value then
    table.insert(lines, 'set -gx PATH ' .. escape_fish(path_value))
  end

  for name, value in pairs(vars) do
    table.insert(lines, 'set -gx ' .. name .. ' ' .. escape_fish(value))
  end

  table.insert(lines, '')
  return table.concat(lines, '\n')
end

--- Generate PowerShell env file content
---@param path_value string|nil
---@param vars table<string, string>
---@return string
local function generate_powershell_env(path_value, vars)
  local lines = {
    '# Generated by syslua - DO NOT EDIT',
    '# This file sets environment variables managed by syslua',
    '',
  }

  if path_value then
    table.insert(lines, '$env:PATH = ' .. escape_powershell(path_value))
  end

  for name, value in pairs(vars) do
    table.insert(lines, '$env:' .. name .. ' = ' .. escape_powershell(value))
  end

  table.insert(lines, '')
  return table.concat(lines, '\n')
end

-- ============================================================================
-- Build and Bind Steps
-- ============================================================================

--- Create the build step that generates env files
---@param opts EnvOptions
---@return table
local function create_env_build(opts)
  local config = serialize_env_config(opts)

  -- Get PATH from mergeable if needed
  local path_value = config.PATH
  if not path_value and opts.PATH then
    -- PATH will be resolved during pairs() on merged table
    path_value = opts.PATH
  end

  return sys.build({
    id = '__syslua_env',
    replace = true,
    inputs = {
      path_value = path_value,
      vars = config.vars,
      os = sys.os,
    },
    create = function(inputs, ctx)
      local posix_content = generate_posix_env(inputs.path_value, inputs.vars)
      local fish_content = generate_fish_env(inputs.path_value, inputs.vars)
      local ps_content = generate_powershell_env(inputs.path_value, inputs.vars)

      -- Write env files
      if sys.os == 'windows' then
        ctx:exec({
          bin = 'powershell.exe',
          args = {
            '-NoProfile',
            '-Command',
            string.format('Set-Content -Path "%s/syslua-env.ps1" -Value %s', ctx.out, escape_powershell(ps_content)),
          },
        })
      else
        ctx:exec({
          bin = '/bin/sh',
          args = {
            '-c',
            string.format('cat > "%s/syslua-env.sh" << \'SYSLUA_EOF\'\n%sSYSLUA_EOF', ctx.out, posix_content),
          },
        })
        ctx:exec({
          bin = '/bin/sh',
          args = {
            '-c',
            string.format('cat > "%s/syslua-env.fish" << \'SYSLUA_EOF\'\n%sSYSLUA_EOF', ctx.out, fish_content),
          },
        })
      end

      return {
        sh = ctx.out .. '/syslua-env.sh',
        fish = ctx.out .. '/syslua-env.fish',
        ps1 = ctx.out .. '/syslua-env.ps1',
      }
    end,
  })
end

--- Create bind steps to source env files from shell configs
---@param build table Build outputs reference
---@param _opts EnvOptions
local function create_env_binds(build, _opts)
  local shell_configs = get_shell_configs()

  -- Marker for identifying our block
  local BEGIN_MARKER = '# BEGIN SYSLUA ENV - DO NOT EDIT'
  local END_MARKER = '# END SYSLUA ENV'

  if sys.os == 'windows' then
    -- PowerShell bind
    sys.bind({
      inputs = {
        build = build,
        config_path = shell_configs.powershell,
        begin_marker = BEGIN_MARKER,
        end_marker = END_MARKER,
      },
      create = function(inputs, ctx)
        local source_block =
          string.format('%s\n. "%s"\n%s', inputs.begin_marker, inputs.build.outputs.ps1, inputs.end_marker)

        -- Create profile directory if needed and add source line
        ctx:exec({
          bin = 'powershell.exe',
          args = {
            '-NoProfile',
            '-Command',
            string.format(
              [[
$configPath = '%s'
$configDir = Split-Path -Parent $configPath
if (-not (Test-Path $configDir)) { New-Item -ItemType Directory -Path $configDir -Force | Out-Null }
if (-not (Test-Path $configPath)) { New-Item -ItemType File -Path $configPath -Force | Out-Null }
$content = Get-Content $configPath -Raw -ErrorAction SilentlyContinue
if ($content -notmatch [regex]::Escape('%s')) {
  Add-Content -Path $configPath -Value "`n%s`n. `"%s`"`n%s"
}
]],
              inputs.config_path,
              inputs.begin_marker,
              inputs.begin_marker,
              inputs.build.outputs.ps1,
              inputs.end_marker
            ),
          },
        })

        return { config = inputs.config_path }
      end,
      destroy = function(outputs, ctx)
        -- Remove our block from the config
        ctx:exec({
          bin = 'powershell.exe',
          args = {
            '-NoProfile',
            '-Command',
            string.format(
              [[
$configPath = '%s'
if (Test-Path $configPath) {
  $content = Get-Content $configPath -Raw
  $pattern = '(?s)%s.*?%s\r?\n?'
  $newContent = $content -replace $pattern, ''
  Set-Content -Path $configPath -Value $newContent -NoNewline
}
]],
              outputs.config,
              BEGIN_MARKER,
              END_MARKER
            ),
          },
        })
      end,
    })
  else
    -- POSIX shells (bash, zsh)
    for _, shell in ipairs({ 'zsh', 'bash' }) do
      local config_path = shell_configs[shell]
      if config_path then
        sys.bind({
          inputs = {
            build = build,
            config_path = config_path,
            shell = shell,
            begin_marker = BEGIN_MARKER,
            end_marker = END_MARKER,
          },
          create = function(inputs, ctx)
            local source_line
            if inputs.shell == 'bash' then
              source_line =
                string.format('[ -f "%s" ] && source "%s"', inputs.build.outputs.sh, inputs.build.outputs.sh)
            else
              source_line = string.format('source "%s"', inputs.build.outputs.sh)
            end

            -- Create config dir/file if needed and add source block
            ctx:exec({
              bin = '/bin/sh',
              args = {
                '-c',
                string.format(
                  [[
config_path="%s"
config_dir=$(dirname "$config_path")
mkdir -p "$config_dir"
touch "$config_path"
if ! grep -qF "%s" "$config_path" 2>/dev/null; then
  printf '\n%s\n%s\n%s\n' >> "$config_path"
fi
]],
                  inputs.config_path,
                  inputs.begin_marker,
                  inputs.begin_marker,
                  source_line,
                  inputs.end_marker
                ),
              },
            })

            return { config = inputs.config_path }
          end,
          destroy = function(outputs, ctx)
            -- Remove our block from the config
            ctx:exec({
              bin = '/bin/sh',
              args = {
                '-c',
                string.format(
                  [[
config_path="%s"
if [ -f "$config_path" ]; then
  sed -i.bak '/%s/,/%s/d' "$config_path" && rm -f "$config_path.bak"
fi
]],
                  outputs.config,
                  BEGIN_MARKER:gsub('[#]', '\\#'),
                  END_MARKER:gsub('[#]', '\\#')
                ),
              },
            })
          end,
        })
      end
    end

    -- Fish shell
    if shell_configs.fish then
      sys.bind({
        inputs = {
          build = build,
          config_path = shell_configs.fish,
          begin_marker = BEGIN_MARKER,
          end_marker = END_MARKER,
        },
        create = function(inputs, ctx)
          local source_line = string.format('source "%s"', inputs.build.outputs.fish)

          ctx:exec({
            bin = '/bin/sh',
            args = {
              '-c',
              string.format(
                [[
config_path="%s"
config_dir=$(dirname "$config_path")
mkdir -p "$config_dir"
touch "$config_path"
if ! grep -qF "%s" "$config_path" 2>/dev/null; then
  printf '\n%s\n%s\n%s\n' >> "$config_path"
fi
]],
                inputs.config_path,
                inputs.begin_marker,
                inputs.begin_marker,
                source_line,
                inputs.end_marker
              ),
            },
          })

          return { config = inputs.config_path }
        end,
        destroy = function(outputs, ctx)
          ctx:exec({
            bin = '/bin/sh',
            args = {
              '-c',
              string.format(
                [[
config_path="%s"
if [ -f "$config_path" ]; then
  sed -i.bak '/%s/,/%s/d' "$config_path" && rm -f "$config_path.bak"
fi
]],
                outputs.config,
                BEGIN_MARKER:gsub('[#]', '\\#'),
                END_MARKER:gsub('[#]', '\\#')
              ),
            },
          })
        end,
      })
    end
  end
end

-- ============================================================================
-- Public API
-- ============================================================================

--- Set up environment variables according to the provided options
---@param provided_opts EnvOptions
M.setup = function(provided_opts)
  local new_opts = prio.merge(M.opts, provided_opts)
  if not new_opts then
    error('Failed to merge env options')
  end

  M.opts = new_opts

  -- Create build that generates env files
  local build = create_env_build(M.opts)

  -- Create binds that source env files from shell configs
  create_env_binds(build, M.opts)
end

return M
